'''
Your goal in this project is to break RSA when the public modulus N is generated incorrectly. 
This should serve as yet another reminder not to implement crypto primitives yourself.

Normally, the primes that comprise an RSA modulus are generated independently of one another. 
But suppose a developer decides to generate the first prime p by choosing a random number R 
and scanning for a prime close by. The second prime q is generated by scanning for some other 
random prime also close to R.

We show that the resulting RSA modulus N=pq can be easily factored.

Suppose you are given a composite N and are told that N is a product of two relatively close
primes p and q, namely p and q satisfy

|p-q|<2*N^(1/4) (*)

Your goal is to factor N.

Let A be the arithmetic average of the two primes, that is A=p+q2. Since p and q are odd, 
we know that p+q is even and therefore A is an integer.

To factor N you first observe that under condition (*) the quantity sqrt(N) is very close to A. 
In particular, we show below that:

A - sqrt(N) < 1

But since A is an integer, rounding sqrt(N) up to the closest integer reveals the value of A. 
In code, A=ceil(sqrt(N)) where "ceil" is the ceiling function.

Visually, the numbers p,q,sqrt(N) and A are ordered as follows: see screen shot

Since A is the exact mid-point between p and q there is an integer x such that p=A - x and q=A + x.

But then N=pq=(A-x)(A+x)=A^2 - x^2 and therefore x=sqrt(A^2 - N).

Now, given x and A you can find the factors p and q of N since p=A-x and q=A+x. 
You have now factored N  !

Further reading: the method described above is a greatly simplified version of a much more 
general result on factoring when the high order bits of the prime factor are known.

In the following challenges, you will factor the given moduli using the method outlined above. 
To solve this assignment it is best to use an environment that supports multi-precision 
arithmetic and square roots. In Python you could use the gmpy2 module. In C you can use GMP.
'''
import numpy as np
#Challenge 1
import math
from math import sqrt
import binascii


def isqrt(n):
    x = n
    y = (x + 1) // 2
    while y < x:
        x = y
        y = (x + n // x) // 2
    return x

def extEuclideanAlg(a, b) :
    """
    Computes a solution  to a x + b y = gcd(a,b), as well as gcd(a,b)
    """
    if b == 0 :
        return 1,0,a
    else :
        x, y, gcd = extEuclideanAlg(b, a % b)
        return y, x - y * (a // b),gcd
 
def modinv(a,m) :
    """
    Computes the modular multiplicative inverse of a modulo m,
    using the extended Euclidean algorithm
    """
    x,y,gcd = extEuclideanAlg(a,m)
    if gcd == 1 :
        return x % m
    else :
        return None
        
def hex_to_str(a):
    x = a
    result = binascii.unhexlify(x)
    return result.decode('ascii');


def findSmallerFactor(n):
    A = long(isqrt(n) +1)
    x = long(isqrt(A**2-n))
    if np.multiply((A-x),(A+x)) == n:
        return A-x


def findSmallerFactor2(n):
    for i in range (1,2**20):
        A = long(isqrt(n) +i)
        x = long(isqrt(A**2-n))
        if np.multiply((A-x),(A+x)) == n:
            return A-x
            
            
            
def findSmallerFactor3(n):
    n6 = np.multiply(6,n)
    A = long(isqrt(n6))
    #math for this has been figured out using knowledge about A
    #then algebra has been computed to solve
    '''
    (A+x)(A-x) = 6N; A=A'+ 0.5  ; x = x' + 0.5
    A^2 - x^2 = 6n
    (A' + .5)^2 - 6n = (x' + .5)^2
    ...etc
    '''
    x = long(np.divide(isqrt(np.multiply(4, A**2+A-n6)+1)-1,2))
    p = np.divide(A-x, 3)
    q = np.divide(A+x+1, 2)
    if np.multiply(p,q) == n:
        return min(p,q)
    else:
        q = np.divide(A-x, 2)
        p = np.divide(A+x+1, 3)
        if np.multiply(p,q) == n:
            return min(p,q)
        return 0
  
def decrypt_to_s(hexDec):
    for i in range (0, len(hexDec)/2):
        if hexDec[2*i:2*i+2]=='00':
            return hexDec[2*i+2:]

  
def decrypt(N, ct, e):
    p = findSmallerFactor(N)
    q = np.divide(N,p)
    phiN = N-p-q+1
    d = modinv(e, phiN)
    decrypted = pow(ct, d, N)
    a = '0'+hex(decrypted)[2:]
    b = decrypt_to_s('0'+hex(decrypted)[2:])
    return hex_to_str(b[:len(b)-1])
    


#Chal 1:
'''
The following modulus N is a products of two primes p and q where |p-q| < 2N^(1/4). 
Find the smaller of the two factors and enter it as a decimal integer in the box below.

See screen shot 2 for more details

Enter the answer for factoring challenge #1 in the box below:
'''

N = long(179769313486231590772930519078902473361797697894230657273430081157732675805505620686985379449212982959585501387537164015710139858647833778606925583497541085196591615128057575940752635007475935288710823649949940771895617054361149474865046711015101563940680527540071584560878577663743040086340742855278549092581)
factor = findSmallerFactor(N)
print 'answer to Chal 1:'
print factor


#Chal 2:
'''
The following modulus N is a products of two primes p and q where |p-q|<2^(11)*N^(1/4). 
Find the smaller of the two factors and enter it as a decimal integer.

Hint: in this case A-sqrt(N)<220 so try scanning for A from sqrt(N) upwards, 
until you succeed in factoring N.
'''
N2 = long(648455842808071669662824265346772278726343720706976263060439070378797308618081116462714015276061417569195587321840254520655424906719892428844841839353281972988531310511738648965962582821502504990264452100885281673303711142296421027840289307657458645233683357077834689715838646088239640236866252211790085787877)

factor2 = findSmallerFactor2(N2)
print 'answer to chal 2:'
print factor2

#Chal 3:
'''
The following modulus N is a product of two primes p and q where |3p-2q|<N^(1/4). 
Find the smaller of the two factors and enter it as a decimal integer.

Hint: first show that sqrt(6N) is close to (3p+2q)/2 and then adapt the method in 
challenge #1 to factor N.
'''
N3 = long(720062263747350425279564435525583738338084451473999841826653057981916355690188337790423408664187663938485175264994017897083524079135686877441155132015188279331812309091996246361896836573643119174094961348524639707885238799396839230364676670221627018353299443241192173812729276147530748597302192751375739387929)

factor3 = findSmallerFactor3(N3)
print 'answer to chal 3:'
print factor3


#Chal 4:
'''
The challenge ciphertext provided below is the result of encrypting a short 
secret ASCII plaintext using the RSA modulus given in the first factorization 
challenge.

The encryption exponent used is e=65537. The ASCII plaintext was encoded using 
PKCS v1.5 before the RSA function was applied, as described in PKCS.

Use the factorization you obtained for this RSA modulus to decrypt this 
challenge ciphertext and enter the resulting English plaintext in the box below. 
Recall that the factorization of N enables you to compute phi(N) from which you 
can obtain the RSA decryption exponent.

After you use the decryption exponent to decrypt the challenge ciphertext you 
will obtain a PKCS1 encoded plaintext. To undo the encoding it is best to write 
the decrypted value in hex. You will observe that the number starts with a 
'0x02' followed by many random non-zero digits. Look for the '0x00' separator 
and the digits following this separator are the ASCII letters of the plaintext.

(note: the separator used here is '0x00', not '0xFF' as stated in the lecture)
'''
ct = 22096451867410381776306561134883418017410069787892831071731839143676135600120538004282329650473509424343946219751512256465839967942889460764542040581564748988013734864120452325229320176487916666402997509188729971690526083222067771600019329260870009579993724077458967773697817571267229951148662959627934791540
e = 65537
print 'answer to chal 4:'
print decrypt(N, ct, e)
